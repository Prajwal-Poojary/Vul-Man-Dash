{"ast":null,"code":"import { BehaviorSubject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./websocket.service\";\nexport let PerformanceService = /*#__PURE__*/(() => {\n  class PerformanceService {\n    webSocketService;\n    performanceMetrics = new Map();\n    metricsSubject = new BehaviorSubject([]);\n    alertsSubject = new BehaviorSubject([]);\n    thresholds = [{\n      metric: 'page-load',\n      warning: 3000,\n      critical: 5000\n    }, {\n      metric: 'api-response',\n      warning: 2000,\n      critical: 4000\n    }, {\n      metric: 'chart-render',\n      warning: 1000,\n      critical: 2000\n    }, {\n      metric: 'memory-usage',\n      warning: 50,\n      critical: 80\n    }];\n    constructor(webSocketService) {\n      this.webSocketService = webSocketService;\n      this.initializePerformanceObserver();\n      this.startPerformanceMonitoring();\n    }\n    initializePerformanceObserver() {\n      if ('PerformanceObserver' in window) {\n        const observer = new PerformanceObserver(list => {\n          for (const entry of list.getEntries()) {\n            this.logPerformanceEntry(entry);\n          }\n        });\n        observer.observe({\n          entryTypes: ['measure', 'navigation', 'resource', 'paint']\n        });\n      }\n    }\n    startPerformanceMonitoring() {\n      // Monitor every 30 seconds\n      setInterval(() => {\n        this.collectSystemMetrics();\n        this.checkPerformanceThresholds();\n      }, 30000);\n      // Initial collection\n      setTimeout(() => {\n        this.collectSystemMetrics();\n      }, 5000);\n    }\n    collectSystemMetrics() {\n      // Memory usage\n      const memoryInfo = this.getMemoryUsage();\n      if (memoryInfo) {\n        const memoryUsagePercent = memoryInfo.usedJSHeapSize / memoryInfo.totalJSHeapSize * 100;\n        this.addMetric('memory-usage', memoryUsagePercent, 'memory');\n      }\n      // Network information\n      if ('connection' in navigator) {\n        const connection = navigator.connection;\n        if (connection) {\n          this.addMetric('network-downlink', connection.downlink || 0, 'network');\n          this.addMetric('network-rtt', connection.rtt || 0, 'network');\n        }\n      }\n      // FPS monitoring\n      this.measureFPS();\n    }\n    measureFPS() {\n      let fps = 0;\n      let lastTime = performance.now();\n      const countFPS = () => {\n        const currentTime = performance.now();\n        fps++;\n        if (currentTime >= lastTime + 1000) {\n          this.addMetric('fps', fps, 'custom');\n          fps = 0;\n          lastTime = currentTime;\n        }\n        requestAnimationFrame(countFPS);\n      };\n      requestAnimationFrame(countFPS);\n    }\n    checkPerformanceThresholds() {\n      for (const threshold of this.thresholds) {\n        const metric = this.performanceMetrics.get(threshold.metric);\n        if (metric) {\n          let alertLevel = null;\n          if (metric.value >= threshold.critical) {\n            alertLevel = 'critical';\n          } else if (metric.value >= threshold.warning) {\n            alertLevel = 'warning';\n          }\n          if (alertLevel) {\n            this.triggerPerformanceAlert(metric, alertLevel, threshold);\n          }\n        }\n      }\n    }\n    triggerPerformanceAlert(metric, level, threshold) {\n      const alert = {\n        type: 'performance-alert',\n        level,\n        metric: metric.name,\n        value: metric.value,\n        threshold: level === 'critical' ? threshold.critical : threshold.warning,\n        timestamp: new Date(),\n        message: `Performance ${level}: ${metric.name} is ${metric.value}ms (threshold: ${level === 'critical' ? threshold.critical : threshold.warning}ms)`\n      };\n      const currentAlerts = this.alertsSubject.value;\n      this.alertsSubject.next([alert, ...currentAlerts]);\n      // Send via WebSocket if connected\n      if (this.webSocketService.isConnected()) {\n        // This would typically be sent from backend, but for demo purposes\n        console.warn('Performance Alert:', alert);\n      }\n    }\n    logPerformanceEntry(entry) {\n      console.log(`Performance: ${entry.name} - ${entry.duration}ms`);\n      this.addMetric(entry.name, entry.duration, 'timing');\n    }\n    addMetric(name, value, type) {\n      const metric = {\n        name,\n        value,\n        timestamp: new Date(),\n        type\n      };\n      this.performanceMetrics.set(name, metric);\n      // Update observable\n      const allMetrics = Array.from(this.performanceMetrics.values());\n      this.metricsSubject.next(allMetrics);\n    }\n    // Public methods\n    markStart(name) {\n      performance.mark(`${name}-start`);\n    }\n    markEnd(name) {\n      performance.mark(`${name}-end`);\n      performance.measure(name, `${name}-start`, `${name}-end`);\n    }\n    getMetrics() {\n      return this.metricsSubject.asObservable();\n    }\n    getAlerts() {\n      return this.alertsSubject.asObservable();\n    }\n    measureChartPerformance(chartName, operation) {\n      const startTime = performance.now();\n      operation();\n      const endTime = performance.now();\n      const duration = endTime - startTime;\n      console.log(`Chart ${chartName} rendered in ${duration}ms`);\n      this.addMetric(`chart-${chartName}`, duration, 'timing');\n    }\n    measureApiCall(apiName, promise) {\n      const startTime = performance.now();\n      return promise.then(result => {\n        const endTime = performance.now();\n        const duration = endTime - startTime;\n        this.addMetric(`api-${apiName}`, duration, 'network');\n        return result;\n      }).catch(error => {\n        const endTime = performance.now();\n        const duration = endTime - startTime;\n        this.addMetric(`api-${apiName}-error`, duration, 'network');\n        throw error;\n      });\n    }\n    getMemoryUsage() {\n      if ('memory' in performance) {\n        return performance.memory;\n      }\n      return null;\n    }\n    logCriticalRenderingPath() {\n      if ('getEntriesByType' in performance) {\n        const navEntries = performance.getEntriesByType('navigation');\n        if (navEntries.length > 0) {\n          const nav = navEntries[0];\n          const metrics = {\n            DNS: nav.domainLookupEnd - nav.domainLookupStart,\n            TCP: nav.connectEnd - nav.connectStart,\n            Request: nav.responseStart - nav.requestStart,\n            Response: nav.responseEnd - nav.responseStart,\n            DOM: nav.domContentLoadedEventEnd - nav.responseEnd,\n            Load: nav.loadEventEnd - nav.loadEventStart\n          };\n          console.log('Critical Rendering Path Metrics:', metrics);\n          // Add each metric\n          Object.entries(metrics).forEach(([name, value]) => {\n            this.addMetric(`crp-${name.toLowerCase()}`, value, 'timing');\n          });\n        }\n      }\n    }\n    getPerformanceReport() {\n      const metrics = Array.from(this.performanceMetrics.values());\n      const alerts = this.alertsSubject.value;\n      return {\n        timestamp: new Date(),\n        metrics: metrics.slice(-20),\n        // Last 20 metrics\n        alerts: alerts.slice(0, 10),\n        // Last 10 alerts\n        memoryUsage: this.getMemoryUsage(),\n        summary: {\n          totalMetrics: metrics.length,\n          totalAlerts: alerts.length,\n          avgResponseTime: this.calculateAverageResponseTime(metrics),\n          memoryUsagePercent: this.calculateMemoryUsagePercent()\n        }\n      };\n    }\n    calculateAverageResponseTime(metrics) {\n      const networkMetrics = metrics.filter(m => m.type === 'network');\n      if (networkMetrics.length === 0) return 0;\n      const sum = networkMetrics.reduce((acc, m) => acc + m.value, 0);\n      return sum / networkMetrics.length;\n    }\n    calculateMemoryUsagePercent() {\n      const memoryInfo = this.getMemoryUsage();\n      if (!memoryInfo) return 0;\n      return memoryInfo.usedJSHeapSize / memoryInfo.totalJSHeapSize * 100;\n    }\n    static ɵfac = function PerformanceService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || PerformanceService)(i0.ɵɵinject(i1.WebSocketService));\n    };\n    static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: PerformanceService,\n      factory: PerformanceService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return PerformanceService;\n})();","map":{"version":3,"names":["BehaviorSubject","PerformanceService","webSocketService","performanceMetrics","Map","metricsSubject","alertsSubject","thresholds","metric","warning","critical","constructor","initializePerformanceObserver","startPerformanceMonitoring","window","observer","PerformanceObserver","list","entry","getEntries","logPerformanceEntry","observe","entryTypes","setInterval","collectSystemMetrics","checkPerformanceThresholds","setTimeout","memoryInfo","getMemoryUsage","memoryUsagePercent","usedJSHeapSize","totalJSHeapSize","addMetric","navigator","connection","downlink","rtt","measureFPS","fps","lastTime","performance","now","countFPS","currentTime","requestAnimationFrame","threshold","get","alertLevel","value","triggerPerformanceAlert","level","alert","type","name","timestamp","Date","message","currentAlerts","next","isConnected","console","warn","log","duration","set","allMetrics","Array","from","values","markStart","mark","markEnd","measure","getMetrics","asObservable","getAlerts","measureChartPerformance","chartName","operation","startTime","endTime","measureApiCall","apiName","promise","then","result","catch","error","memory","logCriticalRenderingPath","navEntries","getEntriesByType","length","nav","metrics","DNS","domainLookupEnd","domainLookupStart","TCP","connectEnd","connectStart","Request","responseStart","requestStart","Response","responseEnd","DOM","domContentLoadedEventEnd","Load","loadEventEnd","loadEventStart","Object","entries","forEach","toLowerCase","getPerformanceReport","alerts","slice","memoryUsage","summary","totalMetrics","totalAlerts","avgResponseTime","calculateAverageResponseTime","calculateMemoryUsagePercent","networkMetrics","filter","m","sum","reduce","acc","i0","ɵɵinject","i1","WebSocketService","factory","ɵfac","providedIn"],"sources":["/app/src/app/services/performance.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport { WebSocketService } from './websocket.service';\n\nexport interface PerformanceMetric {\n  name: string;\n  value: number;\n  timestamp: Date;\n  type: 'timing' | 'memory' | 'network' | 'custom';\n}\n\nexport interface PerformanceThreshold {\n  metric: string;\n  warning: number;\n  critical: number;\n}\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class PerformanceService {\n  private performanceMetrics: Map<string, PerformanceMetric> = new Map();\n  private metricsSubject = new BehaviorSubject<PerformanceMetric[]>([]);\n  private alertsSubject = new BehaviorSubject<any[]>([]);\n  \n  private thresholds: PerformanceThreshold[] = [\n    { metric: 'page-load', warning: 3000, critical: 5000 },\n    { metric: 'api-response', warning: 2000, critical: 4000 },\n    { metric: 'chart-render', warning: 1000, critical: 2000 },\n    { metric: 'memory-usage', warning: 50, critical: 80 }\n  ];\n\n  constructor(private webSocketService: WebSocketService) {\n    this.initializePerformanceObserver();\n    this.startPerformanceMonitoring();\n  }\n\n  private initializePerformanceObserver() {\n    if ('PerformanceObserver' in window) {\n      const observer = new PerformanceObserver((list) => {\n        for (const entry of list.getEntries()) {\n          this.logPerformanceEntry(entry);\n        }\n      });\n      \n      observer.observe({ entryTypes: ['measure', 'navigation', 'resource', 'paint'] });\n    }\n  }\n\n  private startPerformanceMonitoring(): void {\n    // Monitor every 30 seconds\n    setInterval(() => {\n      this.collectSystemMetrics();\n      this.checkPerformanceThresholds();\n    }, 30000);\n    \n    // Initial collection\n    setTimeout(() => {\n      this.collectSystemMetrics();\n    }, 5000);\n  }\n\n  private collectSystemMetrics(): void {\n    // Memory usage\n    const memoryInfo = this.getMemoryUsage();\n    if (memoryInfo) {\n      const memoryUsagePercent = (memoryInfo.usedJSHeapSize / memoryInfo.totalJSHeapSize) * 100;\n      this.addMetric('memory-usage', memoryUsagePercent, 'memory');\n    }\n\n    // Network information\n    if ('connection' in navigator) {\n      const connection = (navigator as any).connection;\n      if (connection) {\n        this.addMetric('network-downlink', connection.downlink || 0, 'network');\n        this.addMetric('network-rtt', connection.rtt || 0, 'network');\n      }\n    }\n\n    // FPS monitoring\n    this.measureFPS();\n  }\n\n  private measureFPS(): void {\n    let fps = 0;\n    let lastTime = performance.now();\n    \n    const countFPS = () => {\n      const currentTime = performance.now();\n      fps++;\n      \n      if (currentTime >= lastTime + 1000) {\n        this.addMetric('fps', fps, 'custom');\n        fps = 0;\n        lastTime = currentTime;\n      }\n      \n      requestAnimationFrame(countFPS);\n    };\n    \n    requestAnimationFrame(countFPS);\n  }\n\n  private checkPerformanceThresholds(): void {\n    for (const threshold of this.thresholds) {\n      const metric = this.performanceMetrics.get(threshold.metric);\n      if (metric) {\n        let alertLevel = null;\n        \n        if (metric.value >= threshold.critical) {\n          alertLevel = 'critical';\n        } else if (metric.value >= threshold.warning) {\n          alertLevel = 'warning';\n        }\n        \n        if (alertLevel) {\n          this.triggerPerformanceAlert(metric, alertLevel, threshold);\n        }\n      }\n    }\n  }\n\n  private triggerPerformanceAlert(metric: PerformanceMetric, level: string, threshold: PerformanceThreshold): void {\n    const alert = {\n      type: 'performance-alert',\n      level,\n      metric: metric.name,\n      value: metric.value,\n      threshold: level === 'critical' ? threshold.critical : threshold.warning,\n      timestamp: new Date(),\n      message: `Performance ${level}: ${metric.name} is ${metric.value}ms (threshold: ${level === 'critical' ? threshold.critical : threshold.warning}ms)`\n    };\n    \n    const currentAlerts = this.alertsSubject.value;\n    this.alertsSubject.next([alert, ...currentAlerts]);\n    \n    // Send via WebSocket if connected\n    if (this.webSocketService.isConnected()) {\n      // This would typically be sent from backend, but for demo purposes\n      console.warn('Performance Alert:', alert);\n    }\n  }\n\n  private logPerformanceEntry(entry: PerformanceEntry) {\n    console.log(`Performance: ${entry.name} - ${entry.duration}ms`);\n    this.addMetric(entry.name, entry.duration, 'timing');\n  }\n\n  private addMetric(name: string, value: number, type: 'timing' | 'memory' | 'network' | 'custom'): void {\n    const metric: PerformanceMetric = {\n      name,\n      value,\n      timestamp: new Date(),\n      type\n    };\n    \n    this.performanceMetrics.set(name, metric);\n    \n    // Update observable\n    const allMetrics = Array.from(this.performanceMetrics.values());\n    this.metricsSubject.next(allMetrics);\n  }\n\n  // Public methods\n  markStart(name: string): void {\n    performance.mark(`${name}-start`);\n  }\n\n  markEnd(name: string): void {\n    performance.mark(`${name}-end`);\n    performance.measure(name, `${name}-start`, `${name}-end`);\n  }\n\n  getMetrics(): Observable<PerformanceMetric[]> {\n    return this.metricsSubject.asObservable();\n  }\n\n  getAlerts(): Observable<any[]> {\n    return this.alertsSubject.asObservable();\n  }\n\n  measureChartPerformance(chartName: string, operation: () => void): void {\n    const startTime = performance.now();\n    operation();\n    const endTime = performance.now();\n    const duration = endTime - startTime;\n    \n    console.log(`Chart ${chartName} rendered in ${duration}ms`);\n    this.addMetric(`chart-${chartName}`, duration, 'timing');\n  }\n\n  measureApiCall(apiName: string, promise: Promise<any>): Promise<any> {\n    const startTime = performance.now();\n    \n    return promise.then(result => {\n      const endTime = performance.now();\n      const duration = endTime - startTime;\n      this.addMetric(`api-${apiName}`, duration, 'network');\n      return result;\n    }).catch(error => {\n      const endTime = performance.now();\n      const duration = endTime - startTime;\n      this.addMetric(`api-${apiName}-error`, duration, 'network');\n      throw error;\n    });\n  }\n\n  getMemoryUsage(): any | null {\n    if ('memory' in performance) {\n      return (performance as any).memory;\n    }\n    return null;\n  }\n\n  logCriticalRenderingPath(): void {\n    if ('getEntriesByType' in performance) {\n      const navEntries = performance.getEntriesByType('navigation');\n      if (navEntries.length > 0) {\n        const nav = navEntries[0] as PerformanceNavigationTiming;\n        const metrics = {\n          DNS: nav.domainLookupEnd - nav.domainLookupStart,\n          TCP: nav.connectEnd - nav.connectStart,\n          Request: nav.responseStart - nav.requestStart,\n          Response: nav.responseEnd - nav.responseStart,\n          DOM: nav.domContentLoadedEventEnd - nav.responseEnd,\n          Load: nav.loadEventEnd - nav.loadEventStart\n        };\n        \n        console.log('Critical Rendering Path Metrics:', metrics);\n        \n        // Add each metric\n        Object.entries(metrics).forEach(([name, value]) => {\n          this.addMetric(`crp-${name.toLowerCase()}`, value, 'timing');\n        });\n      }\n    }\n  }\n\n  getPerformanceReport(): any {\n    const metrics = Array.from(this.performanceMetrics.values());\n    const alerts = this.alertsSubject.value;\n    \n    return {\n      timestamp: new Date(),\n      metrics: metrics.slice(-20), // Last 20 metrics\n      alerts: alerts.slice(0, 10), // Last 10 alerts\n      memoryUsage: this.getMemoryUsage(),\n      summary: {\n        totalMetrics: metrics.length,\n        totalAlerts: alerts.length,\n        avgResponseTime: this.calculateAverageResponseTime(metrics),\n        memoryUsagePercent: this.calculateMemoryUsagePercent()\n      }\n    };\n  }\n\n  private calculateAverageResponseTime(metrics: PerformanceMetric[]): number {\n    const networkMetrics = metrics.filter(m => m.type === 'network');\n    if (networkMetrics.length === 0) return 0;\n    \n    const sum = networkMetrics.reduce((acc, m) => acc + m.value, 0);\n    return sum / networkMetrics.length;\n  }\n\n  private calculateMemoryUsagePercent(): number {\n    const memoryInfo = this.getMemoryUsage();\n    if (!memoryInfo) return 0;\n    \n    return (memoryInfo.usedJSHeapSize / memoryInfo.totalJSHeapSize) * 100;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}