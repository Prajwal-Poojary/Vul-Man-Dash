{"ast":null,"code":"import { Subject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport let IntersectionObserverService = /*#__PURE__*/(() => {\n  class IntersectionObserverService {\n    observers = new Map();\n    subjects = new Map();\n    constructor() {}\n    createObserver(options = {}, observerId = 'default') {\n      if (this.observers.has(observerId)) {\n        return this.subjects.get(observerId).asObservable();\n      }\n      const subject = new Subject();\n      this.subjects.set(observerId, subject);\n      const observer = new IntersectionObserver(entries => {\n        subject.next(entries);\n      }, {\n        rootMargin: '50px',\n        threshold: 0.1,\n        ...options\n      });\n      this.observers.set(observerId, observer);\n      return subject.asObservable();\n    }\n    observe(element, observerId = 'default') {\n      const observer = this.observers.get(observerId);\n      if (observer) {\n        observer.observe(element);\n      }\n    }\n    unobserve(element, observerId = 'default') {\n      const observer = this.observers.get(observerId);\n      if (observer) {\n        observer.unobserve(element);\n      }\n    }\n    disconnect(observerId = 'default') {\n      const observer = this.observers.get(observerId);\n      const subject = this.subjects.get(observerId);\n      if (observer) {\n        observer.disconnect();\n        this.observers.delete(observerId);\n      }\n      if (subject) {\n        subject.complete();\n        this.subjects.delete(observerId);\n      }\n    }\n    ngOnDestroy() {\n      this.observers.forEach((observer, id) => {\n        this.disconnect(id);\n      });\n    }\n    // Lazy loading utility for charts\n    lazyLoadChart(chartContainer, loadCallback, observerId = 'chart-loader') {\n      this.createObserver({\n        rootMargin: '100px',\n        threshold: 0.1\n      }, observerId).subscribe(entries => {\n        entries.forEach(entry => {\n          if (entry.isIntersecting && entry.target === chartContainer) {\n            loadCallback();\n            this.unobserve(chartContainer, observerId);\n          }\n        });\n      });\n      this.observe(chartContainer, observerId);\n    }\n    // Progressive image loading\n    lazyLoadImages(imageElements, observerId = 'image-loader') {\n      this.createObserver({\n        rootMargin: '200px',\n        threshold: 0.1\n      }, observerId).subscribe(entries => {\n        entries.forEach(entry => {\n          if (entry.isIntersecting) {\n            const img = entry.target;\n            const src = img.getAttribute('data-src');\n            if (src) {\n              img.src = src;\n              img.removeAttribute('data-src');\n              img.classList.add('loaded');\n            }\n            this.unobserve(img, observerId);\n          }\n        });\n      });\n      imageElements.forEach(img => this.observe(img, observerId));\n    }\n    static ɵfac = function IntersectionObserverService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IntersectionObserverService)();\n    };\n    static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: IntersectionObserverService,\n      factory: IntersectionObserverService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return IntersectionObserverService;\n})();","map":{"version":3,"names":["Subject","IntersectionObserverService","observers","Map","subjects","constructor","createObserver","options","observerId","has","get","asObservable","subject","set","observer","IntersectionObserver","entries","next","rootMargin","threshold","observe","element","unobserve","disconnect","delete","complete","ngOnDestroy","forEach","id","lazyLoadChart","chartContainer","loadCallback","subscribe","entry","isIntersecting","target","lazyLoadImages","imageElements","img","src","getAttribute","removeAttribute","classList","add","factory","ɵfac","providedIn"],"sources":["/app/src/app/services/intersection-observer.service.ts"],"sourcesContent":["import { Injectable, OnDestroy } from '@angular/core';\nimport { Observable, Subject } from 'rxjs';\n\ninterface IntersectionObserverEntry {\n  target: Element;\n  isIntersecting: boolean;\n  intersectionRatio: number;\n  boundingClientRect: DOMRectReadOnly;\n}\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class IntersectionObserverService implements OnDestroy {\n  private observers: Map<string, IntersectionObserver> = new Map();\n  private subjects: Map<string, Subject<IntersectionObserverEntry[]>> = new Map();\n\n  constructor() {}\n\n  createObserver(\n    options: IntersectionObserverInit = {},\n    observerId = 'default'\n  ): Observable<IntersectionObserverEntry[]> {\n    if (this.observers.has(observerId)) {\n      return this.subjects.get(observerId)!.asObservable();\n    }\n\n    const subject = new Subject<IntersectionObserverEntry[]>();\n    this.subjects.set(observerId, subject);\n\n    const observer = new IntersectionObserver(\n      (entries) => {\n        subject.next(entries);\n      },\n      {\n        rootMargin: '50px',\n        threshold: 0.1,\n        ...options\n      }\n    );\n\n    this.observers.set(observerId, observer);\n    return subject.asObservable();\n  }\n\n  observe(element: Element, observerId = 'default'): void {\n    const observer = this.observers.get(observerId);\n    if (observer) {\n      observer.observe(element);\n    }\n  }\n\n  unobserve(element: Element, observerId = 'default'): void {\n    const observer = this.observers.get(observerId);\n    if (observer) {\n      observer.unobserve(element);\n    }\n  }\n\n  disconnect(observerId = 'default'): void {\n    const observer = this.observers.get(observerId);\n    const subject = this.subjects.get(observerId);\n    \n    if (observer) {\n      observer.disconnect();\n      this.observers.delete(observerId);\n    }\n    \n    if (subject) {\n      subject.complete();\n      this.subjects.delete(observerId);\n    }\n  }\n\n  ngOnDestroy(): void {\n    this.observers.forEach((observer, id) => {\n      this.disconnect(id);\n    });\n  }\n\n  // Lazy loading utility for charts\n  lazyLoadChart(\n    chartContainer: Element,\n    loadCallback: () => void,\n    observerId = 'chart-loader'\n  ): void {\n    this.createObserver({\n      rootMargin: '100px',\n      threshold: 0.1\n    }, observerId).subscribe(entries => {\n      entries.forEach(entry => {\n        if (entry.isIntersecting && entry.target === chartContainer) {\n          loadCallback();\n          this.unobserve(chartContainer, observerId);\n        }\n      });\n    });\n\n    this.observe(chartContainer, observerId);\n  }\n\n  // Progressive image loading\n  lazyLoadImages(\n    imageElements: Element[],\n    observerId = 'image-loader'\n  ): void {\n    this.createObserver({\n      rootMargin: '200px',\n      threshold: 0.1\n    }, observerId).subscribe(entries => {\n      entries.forEach(entry => {\n        if (entry.isIntersecting) {\n          const img = entry.target as HTMLImageElement;\n          const src = img.getAttribute('data-src');\n          if (src) {\n            img.src = src;\n            img.removeAttribute('data-src');\n            img.classList.add('loaded');\n          }\n          this.unobserve(img, observerId);\n        }\n      });\n    });\n\n    imageElements.forEach(img => this.observe(img, observerId));\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}